// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (owner_id, parent_id, nonce, enc_name)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at
`

type CreateFolderParams struct {
	OwnerID  uuid.UUID
	ParentID *uuid.UUID
	Nonce    []byte
	EncName  []byte
}

type CreateFolderRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (CreateFolderRow, error) {
	row := q.db.QueryRow(ctx, createFolder,
		arg.OwnerID,
		arg.ParentID,
		arg.Nonce,
		arg.EncName,
	)
	var i CreateFolderRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createFolderKey = `-- name: CreateFolderKey :exec
INSERT INTO keys (user_id, folder_id, enc_key, nonce, access_level)
VALUES ($1, $2, $3, $4, $5)
`

type CreateFolderKeyParams struct {
	UserID      uuid.UUID
	FolderID    *uuid.UUID
	EncKey      []byte
	Nonce       []byte
	AccessLevel *string
}

func (q *Queries) CreateFolderKey(ctx context.Context, arg CreateFolderKeyParams) error {
	_, err := q.db.Exec(ctx, createFolderKey,
		arg.UserID,
		arg.FolderID,
		arg.EncKey,
		arg.Nonce,
		arg.AccessLevel,
	)
	return err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (owner_id, folder_id, type, nonce, enc_data, enc_overview)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, created_at, updated_at
`

type CreateItemParams struct {
	OwnerID     uuid.UUID
	FolderID    *uuid.UUID
	Type        string
	Nonce       []byte
	EncData     []byte
	EncOverview []byte
}

type CreateItemRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (CreateItemRow, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.OwnerID,
		arg.FolderID,
		arg.Type,
		arg.Nonce,
		arg.EncData,
		arg.EncOverview,
	)
	var i CreateItemRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createItemKey = `-- name: CreateItemKey :exec
INSERT INTO keys (user_id, item_id, enc_key, nonce, access_level)
VALUES ($1, $2, $3, $4, $5)
`

type CreateItemKeyParams struct {
	UserID      uuid.UUID
	ItemID      *uuid.UUID
	EncKey      []byte
	Nonce       []byte
	AccessLevel *string
}

func (q *Queries) CreateItemKey(ctx context.Context, arg CreateItemKeyParams) error {
	_, err := q.db.Exec(ctx, createItemKey,
		arg.UserID,
		arg.ItemID,
		arg.EncKey,
		arg.Nonce,
		arg.AccessLevel,
	)
	return err
}

const getFolderItems = `-- name: GetFolderItems :many
SELECT 
    i.id, 
    i.type, 
    i.nonce AS item_nonce, 
    i.enc_overview, 
    i.updated_at,
    k.enc_key AS wrapped_key, 
    k.nonce AS key_nonce
FROM items i
JOIN keys k ON i.id = k.item_id
WHERE i.folder_id = $1 
  AND k.user_id = $2
  AND i.deleted_at IS NULL
ORDER BY i.created_at DESC
`

type GetFolderItemsParams struct {
	FolderID *uuid.UUID
	UserID   uuid.UUID
}

type GetFolderItemsRow struct {
	ID          uuid.UUID
	Type        string
	ItemNonce   []byte
	EncOverview []byte
	UpdatedAt   time.Time
	WrappedKey  []byte
	KeyNonce    []byte
}

func (q *Queries) GetFolderItems(ctx context.Context, arg GetFolderItemsParams) ([]GetFolderItemsRow, error) {
	rows, err := q.db.Query(ctx, getFolderItems, arg.FolderID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFolderItemsRow
	for rows.Next() {
		var i GetFolderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ItemNonce,
			&i.EncOverview,
			&i.UpdatedAt,
			&i.WrappedKey,
			&i.KeyNonce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemData = `-- name: GetItemData :one
SELECT 
    i.id, 
    i.folder_id,
    i.type, 
    i.nonce AS item_nonce, 
    i.enc_data, 
    i.enc_overview,
    i.created_at, 
    i.updated_at,
    k.enc_key AS wrapped_key, 
    k.nonce AS key_nonce,
    k.access_level
FROM items i
JOIN keys k ON i.id = k.item_id
WHERE i.id = $1 
  AND k.user_id = $2
  AND i.deleted_at IS NULL
`

type GetItemDataParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type GetItemDataRow struct {
	ID          uuid.UUID
	FolderID    *uuid.UUID
	Type        string
	ItemNonce   []byte
	EncData     []byte
	EncOverview []byte
	CreatedAt   time.Time
	UpdatedAt   time.Time
	WrappedKey  []byte
	KeyNonce    []byte
	AccessLevel *string
}

func (q *Queries) GetItemData(ctx context.Context, arg GetItemDataParams) (GetItemDataRow, error) {
	row := q.db.QueryRow(ctx, getItemData, arg.ID, arg.UserID)
	var i GetItemDataRow
	err := row.Scan(
		&i.ID,
		&i.FolderID,
		&i.Type,
		&i.ItemNonce,
		&i.EncData,
		&i.EncOverview,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WrappedKey,
		&i.KeyNonce,
		&i.AccessLevel,
	)
	return i, err
}

const getUserFolders = `-- name: GetUserFolders :many
SELECT 
    f.id, 
    f.parent_id, 
    f.nonce, 
    f.enc_name, 
    f.updated_at,
    k.enc_key AS wrapped_key, 
    k.nonce AS key_nonce,
    k.access_level
FROM folders f
JOIN keys k ON f.id = k.folder_id
WHERE k.user_id = $1 
  AND f.deleted_at IS NULL
ORDER BY f.created_at ASC
`

type GetUserFoldersRow struct {
	ID          uuid.UUID
	ParentID    *uuid.UUID
	Nonce       []byte
	EncName     []byte
	UpdatedAt   time.Time
	WrappedKey  []byte
	KeyNonce    []byte
	AccessLevel *string
}

func (q *Queries) GetUserFolders(ctx context.Context, userID uuid.UUID) ([]GetUserFoldersRow, error) {
	rows, err := q.db.Query(ctx, getUserFolders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserFoldersRow
	for rows.Next() {
		var i GetUserFoldersRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Nonce,
			&i.EncName,
			&i.UpdatedAt,
			&i.WrappedKey,
			&i.KeyNonce,
			&i.AccessLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeUserAccess = `-- name: RevokeUserAccess :exec
DELETE FROM keys 
WHERE user_id = $1 
  AND (folder_id = $2 OR item_id = $2)
`

type RevokeUserAccessParams struct {
	UserID   uuid.UUID
	FolderID *uuid.UUID
}

func (q *Queries) RevokeUserAccess(ctx context.Context, arg RevokeUserAccessParams) error {
	_, err := q.db.Exec(ctx, revokeUserAccess, arg.UserID, arg.FolderID)
	return err
}

const softDeleteFolder = `-- name: SoftDeleteFolder :exec
UPDATE folders 
SET deleted_at = NOW() 
WHERE id = $1 AND owner_id = $2
`

type SoftDeleteFolderParams struct {
	ID      uuid.UUID
	OwnerID uuid.UUID
}

func (q *Queries) SoftDeleteFolder(ctx context.Context, arg SoftDeleteFolderParams) error {
	_, err := q.db.Exec(ctx, softDeleteFolder, arg.ID, arg.OwnerID)
	return err
}

const softDeleteItem = `-- name: SoftDeleteItem :exec
UPDATE items 
SET deleted_at = NOW() 
WHERE id = $1 AND owner_id = $2
`

type SoftDeleteItemParams struct {
	ID      uuid.UUID
	OwnerID uuid.UUID
}

func (q *Queries) SoftDeleteItem(ctx context.Context, arg SoftDeleteItemParams) error {
	_, err := q.db.Exec(ctx, softDeleteItem, arg.ID, arg.OwnerID)
	return err
}
