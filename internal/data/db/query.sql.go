// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (owner_id, nonce, enc_metadata)
VALUES ($1, $2, $3)
RETURNING id, created_at, updated_at
`

type CreateFolderParams struct {
	OwnerID     uuid.UUID
	Nonce       []byte
	EncMetadata []byte
}

type CreateFolderRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (CreateFolderRow, error) {
	row := q.db.QueryRow(ctx, createFolder, arg.OwnerID, arg.Nonce, arg.EncMetadata)
	var i CreateFolderRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createFolderKey = `-- name: CreateFolderKey :exec
INSERT INTO keys (user_id, folder_id, enc_key, nonce, access_level)
VALUES ($1, $2, $3, $4, $5)
`

type CreateFolderKeyParams struct {
	UserID      uuid.UUID
	FolderID    *uuid.UUID
	EncKey      []byte
	Nonce       []byte
	AccessLevel string
}

func (q *Queries) CreateFolderKey(ctx context.Context, arg CreateFolderKeyParams) error {
	_, err := q.db.Exec(ctx, createFolderKey,
		arg.UserID,
		arg.FolderID,
		arg.EncKey,
		arg.Nonce,
		arg.AccessLevel,
	)
	return err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (owner_id, folder_id, type, nonce, enc_data, enc_overview)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, created_at, updated_at
`

type CreateItemParams struct {
	OwnerID     uuid.UUID
	FolderID    *uuid.UUID
	Type        string
	Nonce       []byte
	EncData     []byte
	EncOverview []byte
}

type CreateItemRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (CreateItemRow, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.OwnerID,
		arg.FolderID,
		arg.Type,
		arg.Nonce,
		arg.EncData,
		arg.EncOverview,
	)
	var i CreateItemRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createItemKey = `-- name: CreateItemKey :exec
INSERT INTO keys (user_id, item_id, enc_key, nonce, access_level)
VALUES ($1, $2, $3, $4, $5)
`

type CreateItemKeyParams struct {
	UserID      uuid.UUID
	ItemID      *uuid.UUID
	EncKey      []byte
	Nonce       []byte
	AccessLevel string
}

func (q *Queries) CreateItemKey(ctx context.Context, arg CreateItemKeyParams) error {
	_, err := q.db.Exec(ctx, createItemKey,
		arg.UserID,
		arg.ItemID,
		arg.EncKey,
		arg.Nonce,
		arg.AccessLevel,
	)
	return err
}

const getFolderItems = `-- name: GetFolderItems :many
SELECT
    i.id,
    i.type,
    i.nonce AS item_nonce,
    i.enc_overview,
    i.updated_at,
    k.enc_key AS wrapped_key,
    k.nonce AS key_nonce
FROM items i
JOIN keys k ON i.id = k.item_id
WHERE i.folder_id = $1
  AND k.user_id = $2
  AND i.deleted_at IS NULL
ORDER BY i.created_at DESC
`

type GetFolderItemsParams struct {
	FolderID *uuid.UUID
	UserID   uuid.UUID
}

type GetFolderItemsRow struct {
	ID          uuid.UUID
	Type        string
	ItemNonce   []byte
	EncOverview []byte
	UpdatedAt   time.Time
	WrappedKey  []byte
	KeyNonce    []byte
}

func (q *Queries) GetFolderItems(ctx context.Context, arg GetFolderItemsParams) ([]GetFolderItemsRow, error) {
	rows, err := q.db.Query(ctx, getFolderItems, arg.FolderID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFolderItemsRow
	for rows.Next() {
		var i GetFolderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ItemNonce,
			&i.EncOverview,
			&i.UpdatedAt,
			&i.WrappedKey,
			&i.KeyNonce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemData = `-- name: GetItemData :one
SELECT
    i.id,
    i.folder_id,
    i.type,
    i.nonce AS item_nonce,
    i.enc_data,
    i.enc_overview,
    i.created_at,
    i.updated_at,
    k.enc_key AS wrapped_key,
    k.nonce AS key_nonce,
    k.access_level
FROM items i
JOIN keys k ON i.id = k.item_id
WHERE i.id = $1
  AND k.user_id = $2
  AND i.deleted_at IS NULL
`

type GetItemDataParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type GetItemDataRow struct {
	ID          uuid.UUID
	FolderID    *uuid.UUID
	Type        string
	ItemNonce   []byte
	EncData     []byte
	EncOverview []byte
	CreatedAt   time.Time
	UpdatedAt   time.Time
	WrappedKey  []byte
	KeyNonce    []byte
	AccessLevel string
}

func (q *Queries) GetItemData(ctx context.Context, arg GetItemDataParams) (GetItemDataRow, error) {
	row := q.db.QueryRow(ctx, getItemData, arg.ID, arg.UserID)
	var i GetItemDataRow
	err := row.Scan(
		&i.ID,
		&i.FolderID,
		&i.Type,
		&i.ItemNonce,
		&i.EncData,
		&i.EncOverview,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WrappedKey,
		&i.KeyNonce,
		&i.AccessLevel,
	)
	return i, err
}

const getUserFolders = `-- name: GetUserFolders :many
SELECT
    f.id,
    f.nonce,
    f.enc_metadata,
    f.updated_at,
    k.enc_key AS wrapped_key,
    k.nonce AS key_nonce,
    k.access_level
FROM folders f
JOIN keys k ON f.id = k.folder_id
WHERE k.user_id = $1
  AND f.deleted_at IS NULL
ORDER BY f.created_at ASC
`

type GetUserFoldersRow struct {
	ID          uuid.UUID
	Nonce       []byte
	EncMetadata []byte
	UpdatedAt   time.Time
	WrappedKey  []byte
	KeyNonce    []byte
	AccessLevel string
}

func (q *Queries) GetUserFolders(ctx context.Context, userID uuid.UUID) ([]GetUserFoldersRow, error) {
	rows, err := q.db.Query(ctx, getUserFolders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserFoldersRow
	for rows.Next() {
		var i GetUserFoldersRow
		if err := rows.Scan(
			&i.ID,
			&i.Nonce,
			&i.EncMetadata,
			&i.UpdatedAt,
			&i.WrappedKey,
			&i.KeyNonce,
			&i.AccessLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isFolderOwner = `-- name: IsFolderOwner :one
SELECT 1 FROM folders
WHERE id = $1 AND owner_id = $2
`

type IsFolderOwnerParams struct {
	ID      uuid.UUID
	OwnerID uuid.UUID
}

func (q *Queries) IsFolderOwner(ctx context.Context, arg IsFolderOwnerParams) (int32, error) {
	row := q.db.QueryRow(ctx, isFolderOwner, arg.ID, arg.OwnerID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const isItemOwner = `-- name: IsItemOwner :one
SELECT 1 FROM items
WHERE id = $1 AND owner_id = $2
`

type IsItemOwnerParams struct {
	ID      uuid.UUID
	OwnerID uuid.UUID
}

func (q *Queries) IsItemOwner(ctx context.Context, arg IsItemOwnerParams) (int32, error) {
	row := q.db.QueryRow(ctx, isItemOwner, arg.ID, arg.OwnerID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const revokeUserAccess = `-- name: RevokeUserAccess :exec
DELETE FROM keys
WHERE user_id = $1
  AND (folder_id = $2 OR item_id = $2)
`

type RevokeUserAccessParams struct {
	UserID   uuid.UUID
	FolderID *uuid.UUID
}

func (q *Queries) RevokeUserAccess(ctx context.Context, arg RevokeUserAccessParams) error {
	_, err := q.db.Exec(ctx, revokeUserAccess, arg.UserID, arg.FolderID)
	return err
}

const softDeleteFolder = `-- name: SoftDeleteFolder :execrows
UPDATE folders
SET deleted_at = NOW()
WHERE id = $1 AND owner_id = $2
`

type SoftDeleteFolderParams struct {
	ID      uuid.UUID
	OwnerID uuid.UUID
}

func (q *Queries) SoftDeleteFolder(ctx context.Context, arg SoftDeleteFolderParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteFolder, arg.ID, arg.OwnerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const softDeleteItem = `-- name: SoftDeleteItem :execrows
UPDATE items
SET deleted_at = NOW()
WHERE id = $1 AND owner_id = $2
`

type SoftDeleteItemParams struct {
	ID      uuid.UUID
	OwnerID uuid.UUID
}

func (q *Queries) SoftDeleteItem(ctx context.Context, arg SoftDeleteItemParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteItem, arg.ID, arg.OwnerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateFolderMetadata = `-- name: UpdateFolderMetadata :execrows
UPDATE folders
SET
    enc_metadata = $1,
    nonce = $2,
    updated_at = NOW()
WHERE id = $3 AND owner_id = $4
`

type UpdateFolderMetadataParams struct {
	EncMetadata []byte
	Nonce       []byte
	ID          uuid.UUID
	OwnerID     uuid.UUID
}

func (q *Queries) UpdateFolderMetadata(ctx context.Context, arg UpdateFolderMetadataParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateFolderMetadata,
		arg.EncMetadata,
		arg.Nonce,
		arg.ID,
		arg.OwnerID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateItemBlob = `-- name: UpdateItemBlob :exec
UPDATE items
SET
    enc_data = $1,
    enc_overview = $2,
    nonce = $3,
    updated_at = NOW()
WHERE id = $4
`

type UpdateItemBlobParams struct {
	EncData     []byte
	EncOverview []byte
	Nonce       []byte
	ID          uuid.UUID
}

func (q *Queries) UpdateItemBlob(ctx context.Context, arg UpdateItemBlobParams) error {
	_, err := q.db.Exec(ctx, updateItemBlob,
		arg.EncData,
		arg.EncOverview,
		arg.Nonce,
		arg.ID,
	)
	return err
}
